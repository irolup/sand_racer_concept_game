@tool
extends Node3D


const TRIANGULATIONS = [
[-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
[0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
[0, 1, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
[1, 8, 3, 9, 8, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
[1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
[0, 8, 3, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
[9, 2, 10, 0, 2, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
[2, 8, 3, 2, 10, 8, 10, 9, 8, -1, -1, -1, -1, -1, -1, -1],
[3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
[0, 11, 2, 8, 11, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
[1, 9, 0, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
[1, 11, 2, 1, 9, 11, 9, 8, 11, -1, -1, -1, -1, -1, -1, -1],
[3, 10, 1, 11, 10, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
[0, 10, 1, 0, 8, 10, 8, 11, 10, -1, -1, -1, -1, -1, -1, -1],
[3, 9, 0, 3, 11, 9, 11, 10, 9, -1, -1, -1, -1, -1, -1, -1],
[9, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
[4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
[4, 3, 0, 7, 3, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
[0, 1, 9, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
[4, 1, 9, 4, 7, 1, 7, 3, 1, -1, -1, -1, -1, -1, -1, -1],
[1, 2, 10, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
[3, 4, 7, 3, 0, 4, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1],
[9, 2, 10, 9, 0, 2, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1],
[2, 10, 9, 2, 9, 7, 2, 7, 3, 7, 9, 4, -1, -1, -1, -1],
[8, 4, 7, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
[11, 4, 7, 11, 2, 4, 2, 0, 4, -1, -1, -1, -1, -1, -1, -1],
[9, 0, 1, 8, 4, 7, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1],
[4, 7, 11, 9, 4, 11, 9, 11, 2, 9, 2, 1, -1, -1, -1, -1],
[3, 10, 1, 3, 11, 10, 7, 8, 4, -1, -1, -1, -1, -1, -1, -1],
[1, 11, 10, 1, 4, 11, 1, 0, 4, 7, 11, 4, -1, -1, -1, -1],
[4, 7, 8, 9, 0, 11, 9, 11, 10, 11, 0, 3, -1, -1, -1, -1],
[4, 7, 11, 4, 11, 9, 9, 11, 10, -1, -1, -1, -1, -1, -1, -1],
[9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
[9, 5, 4, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
[0, 5, 4, 1, 5, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
[8, 5, 4, 8, 3, 5, 3, 1, 5, -1, -1, -1, -1, -1, -1, -1],
[1, 2, 10, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
[3, 0, 8, 1, 2, 10, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1],
[5, 2, 10, 5, 4, 2, 4, 0, 2, -1, -1, -1, -1, -1, -1, -1],
[2, 10, 5, 3, 2, 5, 3, 5, 4, 3, 4, 8, -1, -1, -1, -1],
[9, 5, 4, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
[0, 11, 2, 0, 8, 11, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1],
[0, 5, 4, 0, 1, 5, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1],
[2, 1, 5, 2, 5, 8, 2, 8, 11, 4, 8, 5, -1, -1, -1, -1],
[10, 3, 11, 10, 1, 3, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1],
[4, 9, 5, 0, 8, 1, 8, 10, 1, 8, 11, 10, -1, -1, -1, -1],
[5, 4, 0, 5, 0, 11, 5, 11, 10, 11, 0, 3, -1, -1, -1, -1],
[5, 4, 8, 5, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1],
[9, 7, 8, 5, 7, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
[9, 3, 0, 9, 5, 3, 5, 7, 3, -1, -1, -1, -1, -1, -1, -1],
[0, 7, 8, 0, 1, 7, 1, 5, 7, -1, -1, -1, -1, -1, -1, -1],
[1, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
[9, 7, 8, 9, 5, 7, 10, 1, 2, -1, -1, -1, -1, -1, -1, -1],
[10, 1, 2, 9, 5, 0, 5, 3, 0, 5, 7, 3, -1, -1, -1, -1],
[8, 0, 2, 8, 2, 5, 8, 5, 7, 10, 5, 2, -1, -1, -1, -1],
[2, 10, 5, 2, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1],
[7, 9, 5, 7, 8, 9, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1],
[9, 5, 7, 9, 7, 2, 9, 2, 0, 2, 7, 11, -1, -1, -1, -1],
[2, 3, 11, 0, 1, 8, 1, 7, 8, 1, 5, 7, -1, -1, -1, -1],
[11, 2, 1, 11, 1, 7, 7, 1, 5, -1, -1, -1, -1, -1, -1, -1],
[9, 5, 8, 8, 5, 7, 10, 1, 3, 10, 3, 11, -1, -1, -1, -1],
[5, 7, 0, 5, 0, 9, 7, 11, 0, 1, 0, 10, 11, 10, 0, -1],
[11, 10, 0, 11, 0, 3, 10, 5, 0, 8, 0, 7, 5, 7, 0, -1],
[11, 10, 5, 7, 11, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
[10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
[0, 8, 3, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
[9, 0, 1, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
[1, 8, 3, 1, 9, 8, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1],
[1, 6, 5, 2, 6, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
[1, 6, 5, 1, 2, 6, 3, 0, 8, -1, -1, -1, -1, -1, -1, -1],
[9, 6, 5, 9, 0, 6, 0, 2, 6, -1, -1, -1, -1, -1, -1, -1],
[5, 9, 8, 5, 8, 2, 5, 2, 6, 3, 2, 8, -1, -1, -1, -1],
[2, 3, 11, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
[11, 0, 8, 11, 2, 0, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1],
[0, 1, 9, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1],
[5, 10, 6, 1, 9, 2, 9, 11, 2, 9, 8, 11, -1, -1, -1, -1],
[6, 3, 11, 6, 5, 3, 5, 1, 3, -1, -1, -1, -1, -1, -1, -1],
[0, 8, 11, 0, 11, 5, 0, 5, 1, 5, 11, 6, -1, -1, -1, -1],
[3, 11, 6, 0, 3, 6, 0, 6, 5, 0, 5, 9, -1, -1, -1, -1],
[6, 5, 9, 6, 9, 11, 11, 9, 8, -1, -1, -1, -1, -1, -1, -1],
[5, 10, 6, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
[4, 3, 0, 4, 7, 3, 6, 5, 10, -1, -1, -1, -1, -1, -1, -1],
[1, 9, 0, 5, 10, 6, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1],
[10, 6, 5, 1, 9, 7, 1, 7, 3, 7, 9, 4, -1, -1, -1, -1],
[6, 1, 2, 6, 5, 1, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1],
[1, 2, 5, 5, 2, 6, 3, 0, 4, 3, 4, 7, -1, -1, -1, -1],
[8, 4, 7, 9, 0, 5, 0, 6, 5, 0, 2, 6, -1, -1, -1, -1],
[7, 3, 9, 7, 9, 4, 3, 2, 9, 5, 9, 6, 2, 6, 9, -1],
[3, 11, 2, 7, 8, 4, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1],
[5, 10, 6, 4, 7, 2, 4, 2, 0, 2, 7, 11, -1, -1, -1, -1],
[0, 1, 9, 4, 7, 8, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1],
[9, 2, 1, 9, 11, 2, 9, 4, 11, 7, 11, 4, 5, 10, 6, -1],
[8, 4, 7, 3, 11, 5, 3, 5, 1, 5, 11, 6, -1, -1, -1, -1],
[5, 1, 11, 5, 11, 6, 1, 0, 11, 7, 11, 4, 0, 4, 11, -1],
[0, 5, 9, 0, 6, 5, 0, 3, 6, 11, 6, 3, 8, 4, 7, -1],
[6, 5, 9, 6, 9, 11, 4, 7, 9, 7, 11, 9, -1, -1, -1, -1],
[10, 4, 9, 6, 4, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
[4, 10, 6, 4, 9, 10, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1],
[10, 0, 1, 10, 6, 0, 6, 4, 0, -1, -1, -1, -1, -1, -1, -1],
[8, 3, 1, 8, 1, 6, 8, 6, 4, 6, 1, 10, -1, -1, -1, -1],
[1, 4, 9, 1, 2, 4, 2, 6, 4, -1, -1, -1, -1, -1, -1, -1],
[3, 0, 8, 1, 2, 9, 2, 4, 9, 2, 6, 4, -1, -1, -1, -1],
[0, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
[8, 3, 2, 8, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1],
[10, 4, 9, 10, 6, 4, 11, 2, 3, -1, -1, -1, -1, -1, -1, -1],
[0, 8, 2, 2, 8, 11, 4, 9, 10, 4, 10, 6, -1, -1, -1, -1],
[3, 11, 2, 0, 1, 6, 0, 6, 4, 6, 1, 10, -1, -1, -1, -1],
[6, 4, 1, 6, 1, 10, 4, 8, 1, 2, 1, 11, 8, 11, 1, -1],
[9, 6, 4, 9, 3, 6, 9, 1, 3, 11, 6, 3, -1, -1, -1, -1],
[8, 11, 1, 8, 1, 0, 11, 6, 1, 9, 1, 4, 6, 4, 1, -1],
[3, 11, 6, 3, 6, 0, 0, 6, 4, -1, -1, -1, -1, -1, -1, -1],
[6, 4, 8, 11, 6, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
[7, 10, 6, 7, 8, 10, 8, 9, 10, -1, -1, -1, -1, -1, -1, -1],
[0, 7, 3, 0, 10, 7, 0, 9, 10, 6, 7, 10, -1, -1, -1, -1],
[10, 6, 7, 1, 10, 7, 1, 7, 8, 1, 8, 0, -1, -1, -1, -1],
[10, 6, 7, 10, 7, 1, 1, 7, 3, -1, -1, -1, -1, -1, -1, -1],
[1, 2, 6, 1, 6, 8, 1, 8, 9, 8, 6, 7, -1, -1, -1, -1],
[2, 6, 9, 2, 9, 1, 6, 7, 9, 0, 9, 3, 7, 3, 9, -1],
[7, 8, 0, 7, 0, 6, 6, 0, 2, -1, -1, -1, -1, -1, -1, -1],
[7, 3, 2, 6, 7, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
[2, 3, 11, 10, 6, 8, 10, 8, 9, 8, 6, 7, -1, -1, -1, -1],
[2, 0, 7, 2, 7, 11, 0, 9, 7, 6, 7, 10, 9, 10, 7, -1],
[1, 8, 0, 1, 7, 8, 1, 10, 7, 6, 7, 10, 2, 3, 11, -1],
[11, 2, 1, 11, 1, 7, 10, 6, 1, 6, 7, 1, -1, -1, -1, -1],
[8, 9, 6, 8, 6, 7, 9, 1, 6, 11, 6, 3, 1, 3, 6, -1],
[0, 9, 1, 11, 6, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
[7, 8, 0, 7, 0, 6, 3, 11, 0, 11, 6, 0, -1, -1, -1, -1],
[7, 11, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
[7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
[3, 0, 8, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
[0, 1, 9, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
[8, 1, 9, 8, 3, 1, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1],
[10, 1, 2, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
[1, 2, 10, 3, 0, 8, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1],
[2, 9, 0, 2, 10, 9, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1],
[6, 11, 7, 2, 10, 3, 10, 8, 3, 10, 9, 8, -1, -1, -1, -1],
[7, 2, 3, 6, 2, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
[7, 0, 8, 7, 6, 0, 6, 2, 0, -1, -1, -1, -1, -1, -1, -1],
[2, 7, 6, 2, 3, 7, 0, 1, 9, -1, -1, -1, -1, -1, -1, -1],
[1, 6, 2, 1, 8, 6, 1, 9, 8, 8, 7, 6, -1, -1, -1, -1],
[10, 7, 6, 10, 1, 7, 1, 3, 7, -1, -1, -1, -1, -1, -1, -1],
[10, 7, 6, 1, 7, 10, 1, 8, 7, 1, 0, 8, -1, -1, -1, -1],
[0, 3, 7, 0, 7, 10, 0, 10, 9, 6, 10, 7, -1, -1, -1, -1],
[7, 6, 10, 7, 10, 8, 8, 10, 9, -1, -1, -1, -1, -1, -1, -1],
[6, 8, 4, 11, 8, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
[3, 6, 11, 3, 0, 6, 0, 4, 6, -1, -1, -1, -1, -1, -1, -1],
[8, 6, 11, 8, 4, 6, 9, 0, 1, -1, -1, -1, -1, -1, -1, -1],
[9, 4, 6, 9, 6, 3, 9, 3, 1, 11, 3, 6, -1, -1, -1, -1],
[6, 8, 4, 6, 11, 8, 2, 10, 1, -1, -1, -1, -1, -1, -1, -1],
[1, 2, 10, 3, 0, 11, 0, 6, 11, 0, 4, 6, -1, -1, -1, -1],
[4, 11, 8, 4, 6, 11, 0, 2, 9, 2, 10, 9, -1, -1, -1, -1],
[10, 9, 3, 10, 3, 2, 9, 4, 3, 11, 3, 6, 4, 6, 3, -1],
[8, 2, 3, 8, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1],
[0, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
[1, 9, 0, 2, 3, 4, 2, 4, 6, 4, 3, 8, -1, -1, -1, -1],
[1, 9, 4, 1, 4, 2, 2, 4, 6, -1, -1, -1, -1, -1, -1, -1],
[8, 1, 3, 8, 6, 1, 8, 4, 6, 6, 10, 1, -1, -1, -1, -1],
[10, 1, 0, 10, 0, 6, 6, 0, 4, -1, -1, -1, -1, -1, -1, -1],
[4, 6, 3, 4, 3, 8, 6, 10, 3, 0, 3, 9, 10, 9, 3, -1],
[10, 9, 4, 6, 10, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
[4, 9, 5, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
[0, 8, 3, 4, 9, 5, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1],
[5, 0, 1, 5, 4, 0, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1],
[11, 7, 6, 8, 3, 4, 3, 5, 4, 3, 1, 5, -1, -1, -1, -1],
[9, 5, 4, 10, 1, 2, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1],
[6, 11, 7, 1, 2, 10, 0, 8, 3, 4, 9, 5, -1, -1, -1, -1],
[7, 6, 11, 5, 4, 10, 4, 2, 10, 4, 0, 2, -1, -1, -1, -1],
[3, 4, 8, 3, 5, 4, 3, 2, 5, 10, 5, 2, 11, 7, 6, -1],
[7, 2, 3, 7, 6, 2, 5, 4, 9, -1, -1, -1, -1, -1, -1, -1],
[9, 5, 4, 0, 8, 6, 0, 6, 2, 6, 8, 7, -1, -1, -1, -1],
[3, 6, 2, 3, 7, 6, 1, 5, 0, 5, 4, 0, -1, -1, -1, -1],
[6, 2, 8, 6, 8, 7, 2, 1, 8, 4, 8, 5, 1, 5, 8, -1],
[9, 5, 4, 10, 1, 6, 1, 7, 6, 1, 3, 7, -1, -1, -1, -1],
[1, 6, 10, 1, 7, 6, 1, 0, 7, 8, 7, 0, 9, 5, 4, -1],
[4, 0, 10, 4, 10, 5, 0, 3, 10, 6, 10, 7, 3, 7, 10, -1],
[7, 6, 10, 7, 10, 8, 5, 4, 10, 4, 8, 10, -1, -1, -1, -1],
[6, 9, 5, 6, 11, 9, 11, 8, 9, -1, -1, -1, -1, -1, -1, -1],
[3, 6, 11, 0, 6, 3, 0, 5, 6, 0, 9, 5, -1, -1, -1, -1],
[0, 11, 8, 0, 5, 11, 0, 1, 5, 5, 6, 11, -1, -1, -1, -1],
[6, 11, 3, 6, 3, 5, 5, 3, 1, -1, -1, -1, -1, -1, -1, -1],
[1, 2, 10, 9, 5, 11, 9, 11, 8, 11, 5, 6, -1, -1, -1, -1],
[0, 11, 3, 0, 6, 11, 0, 9, 6, 5, 6, 9, 1, 2, 10, -1],
[11, 8, 5, 11, 5, 6, 8, 0, 5, 10, 5, 2, 0, 2, 5, -1],
[6, 11, 3, 6, 3, 5, 2, 10, 3, 10, 5, 3, -1, -1, -1, -1],
[5, 8, 9, 5, 2, 8, 5, 6, 2, 3, 8, 2, -1, -1, -1, -1],
[9, 5, 6, 9, 6, 0, 0, 6, 2, -1, -1, -1, -1, -1, -1, -1],
[1, 5, 8, 1, 8, 0, 5, 6, 8, 3, 8, 2, 6, 2, 8, -1],
[1, 5, 6, 2, 1, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
[1, 3, 6, 1, 6, 10, 3, 8, 6, 5, 6, 9, 8, 9, 6, -1],
[10, 1, 0, 10, 0, 6, 9, 5, 0, 5, 6, 0, -1, -1, -1, -1],
[0, 3, 8, 5, 6, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
[10, 5, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
[11, 5, 10, 7, 5, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
[11, 5, 10, 11, 7, 5, 8, 3, 0, -1, -1, -1, -1, -1, -1, -1],
[5, 11, 7, 5, 10, 11, 1, 9, 0, -1, -1, -1, -1, -1, -1, -1],
[10, 7, 5, 10, 11, 7, 9, 8, 1, 8, 3, 1, -1, -1, -1, -1],
[11, 1, 2, 11, 7, 1, 7, 5, 1, -1, -1, -1, -1, -1, -1, -1],
[0, 8, 3, 1, 2, 7, 1, 7, 5, 7, 2, 11, -1, -1, -1, -1],
[9, 7, 5, 9, 2, 7, 9, 0, 2, 2, 11, 7, -1, -1, -1, -1],
[7, 5, 2, 7, 2, 11, 5, 9, 2, 3, 2, 8, 9, 8, 2, -1],
[2, 5, 10, 2, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1],
[8, 2, 0, 8, 5, 2, 8, 7, 5, 10, 2, 5, -1, -1, -1, -1],
[9, 0, 1, 5, 10, 3, 5, 3, 7, 3, 10, 2, -1, -1, -1, -1],
[9, 8, 2, 9, 2, 1, 8, 7, 2, 10, 2, 5, 7, 5, 2, -1],
[1, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
[0, 8, 7, 0, 7, 1, 1, 7, 5, -1, -1, -1, -1, -1, -1, -1],
[9, 0, 3, 9, 3, 5, 5, 3, 7, -1, -1, -1, -1, -1, -1, -1],
[9, 8, 7, 5, 9, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
[5, 8, 4, 5, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1],
[5, 0, 4, 5, 11, 0, 5, 10, 11, 11, 3, 0, -1, -1, -1, -1],
[0, 1, 9, 8, 4, 10, 8, 10, 11, 10, 4, 5, -1, -1, -1, -1],
[10, 11, 4, 10, 4, 5, 11, 3, 4, 9, 4, 1, 3, 1, 4, -1],
[2, 5, 1, 2, 8, 5, 2, 11, 8, 4, 5, 8, -1, -1, -1, -1],
[0, 4, 11, 0, 11, 3, 4, 5, 11, 2, 11, 1, 5, 1, 11, -1],
[0, 2, 5, 0, 5, 9, 2, 11, 5, 4, 5, 8, 11, 8, 5, -1],
[9, 4, 5, 2, 11, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
[2, 5, 10, 3, 5, 2, 3, 4, 5, 3, 8, 4, -1, -1, -1, -1],
[5, 10, 2, 5, 2, 4, 4, 2, 0, -1, -1, -1, -1, -1, -1, -1],
[3, 10, 2, 3, 5, 10, 3, 8, 5, 4, 5, 8, 0, 1, 9, -1],
[5, 10, 2, 5, 2, 4, 1, 9, 2, 9, 4, 2, -1, -1, -1, -1],
[8, 4, 5, 8, 5, 3, 3, 5, 1, -1, -1, -1, -1, -1, -1, -1],
[0, 4, 5, 1, 0, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
[8, 4, 5, 8, 5, 3, 9, 0, 5, 0, 3, 5, -1, -1, -1, -1],
[9, 4, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
[4, 11, 7, 4, 9, 11, 9, 10, 11, -1, -1, -1, -1, -1, -1, -1],
[0, 8, 3, 4, 9, 7, 9, 11, 7, 9, 10, 11, -1, -1, -1, -1],
[1, 10, 11, 1, 11, 4, 1, 4, 0, 7, 4, 11, -1, -1, -1, -1],
[3, 1, 4, 3, 4, 8, 1, 10, 4, 7, 4, 11, 10, 11, 4, -1],
[4, 11, 7, 9, 11, 4, 9, 2, 11, 9, 1, 2, -1, -1, -1, -1],
[9, 7, 4, 9, 11, 7, 9, 1, 11, 2, 11, 1, 0, 8, 3, -1],
[11, 7, 4, 11, 4, 2, 2, 4, 0, -1, -1, -1, -1, -1, -1, -1],
[11, 7, 4, 11, 4, 2, 8, 3, 4, 3, 2, 4, -1, -1, -1, -1],
[2, 9, 10, 2, 7, 9, 2, 3, 7, 7, 4, 9, -1, -1, -1, -1],
[9, 10, 7, 9, 7, 4, 10, 2, 7, 8, 7, 0, 2, 0, 7, -1],
[3, 7, 10, 3, 10, 2, 7, 4, 10, 1, 10, 0, 4, 0, 10, -1],
[1, 10, 2, 8, 7, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
[4, 9, 1, 4, 1, 7, 7, 1, 3, -1, -1, -1, -1, -1, -1, -1],
[4, 9, 1, 4, 1, 7, 0, 8, 1, 8, 7, 1, -1, -1, -1, -1],
[4, 0, 3, 7, 4, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
[4, 8, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
[9, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
[3, 0, 9, 3, 9, 11, 11, 9, 10, -1, -1, -1, -1, -1, -1, -1],
[0, 1, 10, 0, 10, 8, 8, 10, 11, -1, -1, -1, -1, -1, -1, -1],
[3, 1, 10, 11, 3, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
[1, 2, 11, 1, 11, 9, 9, 11, 8, -1, -1, -1, -1, -1, -1, -1],
[3, 0, 9, 3, 9, 11, 1, 2, 9, 2, 11, 9, -1, -1, -1, -1],
[0, 2, 11, 8, 0, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
[3, 2, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
[2, 3, 8, 2, 8, 10, 10, 8, 9, -1, -1, -1, -1, -1, -1, -1],
[9, 10, 2, 0, 9, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
[2, 3, 8, 2, 8, 10, 0, 1, 8, 1, 10, 8, -1, -1, -1, -1],
[1, 10, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
[1, 3, 8, 9, 1, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
[0, 9, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
[0, 3, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
[-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1]]

const POINTS = [
	Vector3i(0, 0, 0),
	Vector3i(0, 0, 1),
	Vector3i(1, 0, 1),
	Vector3i(1, 0, 0),
	Vector3i(0, 1, 0),
	Vector3i(0, 1, 1),
	Vector3i(1, 1, 1),
	Vector3i(1, 1, 0),
]

const EDGES = [
	Vector2i(0, 1),
	Vector2i(1, 2),
	Vector2i(2, 3),
	Vector2i(3, 0),
	Vector2i(4, 5),
	Vector2i(5, 6),
	Vector2i(6, 7),
	Vector2i(7, 4),
	Vector2i(0, 4),
	Vector2i(1, 5),
	Vector2i(2, 6),
	Vector2i(3, 7),
]

static func get_edges() -> Array:
	return [
		Vector2i(0, 1),
		Vector2i(1, 2),
		Vector2i(2, 3),
		Vector2i(3, 0),
		Vector2i(4, 5),
		Vector2i(5, 6),
		Vector2i(6, 7),
		Vector2i(7, 4),
		Vector2i(0, 4),
		Vector2i(1, 5),
		Vector2i(2, 6),
		Vector2i(3, 7),
	]
	
static func get_points() -> Array:
	return [
		Vector3i(0, 0, 0),
		Vector3i(0, 0, 1),
		Vector3i(1, 0, 1),
		Vector3i(1, 0, 0),
		Vector3i(0, 1, 0),
		Vector3i(0, 1, 1),
		Vector3i(1, 1, 1),
		Vector3i(1, 1, 0),
	]

static func get_triangulations() -> Array:
	return [
		[-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
		[0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
		[0, 1, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
		[1, 8, 3, 9, 8, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
		[1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
		[0, 8, 3, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
		[9, 2, 10, 0, 2, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
		[2, 8, 3, 2, 10, 8, 10, 9, 8, -1, -1, -1, -1, -1, -1, -1],
		[3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
		[0, 11, 2, 8, 11, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
		[1, 9, 0, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
		[1, 11, 2, 1, 9, 11, 9, 8, 11, -1, -1, -1, -1, -1, -1, -1],
		[3, 10, 1, 11, 10, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
		[0, 10, 1, 0, 8, 10, 8, 11, 10, -1, -1, -1, -1, -1, -1, -1],
		[3, 9, 0, 3, 11, 9, 11, 10, 9, -1, -1, -1, -1, -1, -1, -1],
		[9, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
		[4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
		[4, 3, 0, 7, 3, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
		[0, 1, 9, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
		[4, 1, 9, 4, 7, 1, 7, 3, 1, -1, -1, -1, -1, -1, -1, -1],
		[1, 2, 10, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
		[3, 4, 7, 3, 0, 4, 1, 2, 10, -1, -1, -1, -1, -1, -1, -1],
		[9, 2, 10, 9, 0, 2, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1],
		[2, 10, 9, 2, 9, 7, 2, 7, 3, 7, 9, 4, -1, -1, -1, -1],
		[8, 4, 7, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
		[11, 4, 7, 11, 2, 4, 2, 0, 4, -1, -1, -1, -1, -1, -1, -1],
		[9, 0, 1, 8, 4, 7, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1],
		[4, 7, 11, 9, 4, 11, 9, 11, 2, 9, 2, 1, -1, -1, -1, -1],
		[3, 10, 1, 3, 11, 10, 7, 8, 4, -1, -1, -1, -1, -1, -1, -1],
		[1, 11, 10, 1, 4, 11, 1, 0, 4, 7, 11, 4, -1, -1, -1, -1],
		[4, 7, 8, 9, 0, 11, 9, 11, 10, 11, 0, 3, -1, -1, -1, -1],
		[4, 7, 11, 4, 11, 9, 9, 11, 10, -1, -1, -1, -1, -1, -1, -1],
		[9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
		[9, 5, 4, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
		[0, 5, 4, 1, 5, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
		[8, 5, 4, 8, 3, 5, 3, 1, 5, -1, -1, -1, -1, -1, -1, -1],
		[1, 2, 10, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
		[3, 0, 8, 1, 2, 10, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1],
		[5, 2, 10, 5, 4, 2, 4, 0, 2, -1, -1, -1, -1, -1, -1, -1],
		[2, 10, 5, 3, 2, 5, 3, 5, 4, 3, 4, 8, -1, -1, -1, -1],
		[9, 5, 4, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
		[0, 11, 2, 0, 8, 11, 4, 9, 5, -1, -1, -1, -1, -1, -1, -1],
		[0, 5, 4, 0, 1, 5, 2, 3, 11, -1, -1, -1, -1, -1, -1, -1],
		[2, 1, 5, 2, 5, 8, 2, 8, 11, 4, 8, 5, -1, -1, -1, -1],
		[10, 3, 11, 10, 1, 3, 9, 5, 4, -1, -1, -1, -1, -1, -1, -1],
		[4, 9, 5, 0, 8, 1, 8, 10, 1, 8, 11, 10, -1, -1, -1, -1],
		[5, 4, 0, 5, 0, 11, 5, 11, 10, 11, 0, 3, -1, -1, -1, -1],
		[5, 4, 8, 5, 8, 10, 10, 8, 11, -1, -1, -1, -1, -1, -1, -1],
		[9, 7, 8, 5, 7, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
		[9, 3, 0, 9, 5, 3, 5, 7, 3, -1, -1, -1, -1, -1, -1, -1],
		[0, 7, 8, 0, 1, 7, 1, 5, 7, -1, -1, -1, -1, -1, -1, -1],
		[1, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
		[9, 7, 8, 9, 5, 7, 10, 1, 2, -1, -1, -1, -1, -1, -1, -1],
		[10, 1, 2, 9, 5, 0, 5, 3, 0, 5, 7, 3, -1, -1, -1, -1],
		[8, 0, 2, 8, 2, 5, 8, 5, 7, 10, 5, 2, -1, -1, -1, -1],
		[2, 10, 5, 2, 5, 3, 3, 5, 7, -1, -1, -1, -1, -1, -1, -1],
		[7, 9, 5, 7, 8, 9, 3, 11, 2, -1, -1, -1, -1, -1, -1, -1],
		[9, 5, 7, 9, 7, 2, 9, 2, 0, 2, 7, 11, -1, -1, -1, -1],
		[2, 3, 11, 0, 1, 8, 1, 7, 8, 1, 5, 7, -1, -1, -1, -1],
		[11, 2, 1, 11, 1, 7, 7, 1, 5, -1, -1, -1, -1, -1, -1, -1],
		[9, 5, 8, 8, 5, 7, 10, 1, 3, 10, 3, 11, -1, -1, -1, -1],
		[5, 7, 0, 5, 0, 9, 7, 11, 0, 1, 0, 10, 11, 10, 0, -1],
		[11, 10, 0, 11, 0, 3, 10, 5, 0, 8, 0, 7, 5, 7, 0, -1],
		[11, 10, 5, 7, 11, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
		[10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
		[0, 8, 3, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
		[9, 0, 1, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
		[1, 8, 3, 1, 9, 8, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1],
		[1, 6, 5, 2, 6, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
		[1, 6, 5, 1, 2, 6, 3, 0, 8, -1, -1, -1, -1, -1, -1, -1],
		[9, 6, 5, 9, 0, 6, 0, 2, 6, -1, -1, -1, -1, -1, -1, -1],
		[5, 9, 8, 5, 8, 2, 5, 2, 6, 3, 2, 8, -1, -1, -1, -1],
		[2, 3, 11, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
		[11, 0, 8, 11, 2, 0, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1],
		[0, 1, 9, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1, -1, -1, -1],
		[5, 10, 6, 1, 9, 2, 9, 11, 2, 9, 8, 11, -1, -1, -1, -1],
		[6, 3, 11, 6, 5, 3, 5, 1, 3, -1, -1, -1, -1, -1, -1, -1],
		[0, 8, 11, 0, 11, 5, 0, 5, 1, 5, 11, 6, -1, -1, -1, -1],
		[3, 11, 6, 0, 3, 6, 0, 6, 5, 0, 5, 9, -1, -1, -1, -1],
		[6, 5, 9, 6, 9, 11, 11, 9, 8, -1, -1, -1, -1, -1, -1, -1],
		[5, 10, 6, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
		[4, 3, 0, 4, 7, 3, 6, 5, 10, -1, -1, -1, -1, -1, -1, -1],
		[1, 9, 0, 5, 10, 6, 8, 4, 7, -1, -1, -1, -1, -1, -1, -1],
		[10, 6, 5, 1, 9, 7, 1, 7, 3, 7, 9, 4, -1, -1, -1, -1],
		[6, 1, 2, 6, 5, 1, 4, 7, 8, -1, -1, -1, -1, -1, -1, -1],
		[1, 2, 5, 5, 2, 6, 3, 0, 4, 3, 4, 7, -1, -1, -1, -1],
		[8, 4, 7, 9, 0, 5, 0, 6, 5, 0, 2, 6, -1, -1, -1, -1],
		[7, 3, 9, 7, 9, 4, 3, 2, 9, 5, 9, 6, 2, 6, 9, -1],
		[3, 11, 2, 7, 8, 4, 10, 6, 5, -1, -1, -1, -1, -1, -1, -1],
		[5, 10, 6, 4, 7, 2, 4, 2, 0, 2, 7, 11, -1, -1, -1, -1],
		[0, 1, 9, 4, 7, 8, 2, 3, 11, 5, 10, 6, -1, -1, -1, -1],
		[9, 2, 1, 9, 11, 2, 9, 4, 11, 7, 11, 4, 5, 10, 6, -1],
		[8, 4, 7, 3, 11, 5, 3, 5, 1, 5, 11, 6, -1, -1, -1, -1],
		[5, 1, 11, 5, 11, 6, 1, 0, 11, 7, 11, 4, 0, 4, 11, -1],
		[0, 5, 9, 0, 6, 5, 0, 3, 6, 11, 6, 3, 8, 4, 7, -1],
		[6, 5, 9, 6, 9, 11, 4, 7, 9, 7, 11, 9, -1, -1, -1, -1],
		[10, 4, 9, 6, 4, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
		[4, 10, 6, 4, 9, 10, 0, 8, 3, -1, -1, -1, -1, -1, -1, -1],
		[10, 0, 1, 10, 6, 0, 6, 4, 0, -1, -1, -1, -1, -1, -1, -1],
		[8, 3, 1, 8, 1, 6, 8, 6, 4, 6, 1, 10, -1, -1, -1, -1],
		[1, 4, 9, 1, 2, 4, 2, 6, 4, -1, -1, -1, -1, -1, -1, -1],
		[3, 0, 8, 1, 2, 9, 2, 4, 9, 2, 6, 4, -1, -1, -1, -1],
		[0, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
		[8, 3, 2, 8, 2, 4, 4, 2, 6, -1, -1, -1, -1, -1, -1, -1],
		[10, 4, 9, 10, 6, 4, 11, 2, 3, -1, -1, -1, -1, -1, -1, -1],
		[0, 8, 2, 2, 8, 11, 4, 9, 10, 4, 10, 6, -1, -1, -1, -1],
		[3, 11, 2, 0, 1, 6, 0, 6, 4, 6, 1, 10, -1, -1, -1, -1],
		[6, 4, 1, 6, 1, 10, 4, 8, 1, 2, 1, 11, 8, 11, 1, -1],
		[9, 6, 4, 9, 3, 6, 9, 1, 3, 11, 6, 3, -1, -1, -1, -1],
		[8, 11, 1, 8, 1, 0, 11, 6, 1, 9, 1, 4, 6, 4, 1, -1],
		[3, 11, 6, 3, 6, 0, 0, 6, 4, -1, -1, -1, -1, -1, -1, -1],
		[6, 4, 8, 11, 6, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
		[7, 10, 6, 7, 8, 10, 8, 9, 10, -1, -1, -1, -1, -1, -1, -1],
		[0, 7, 3, 0, 10, 7, 0, 9, 10, 6, 7, 10, -1, -1, -1, -1],
		[10, 6, 7, 1, 10, 7, 1, 7, 8, 1, 8, 0, -1, -1, -1, -1],
		[10, 6, 7, 10, 7, 1, 1, 7, 3, -1, -1, -1, -1, -1, -1, -1],
		[1, 2, 6, 1, 6, 8, 1, 8, 9, 8, 6, 7, -1, -1, -1, -1],
		[2, 6, 9, 2, 9, 1, 6, 7, 9, 0, 9, 3, 7, 3, 9, -1],
		[7, 8, 0, 7, 0, 6, 6, 0, 2, -1, -1, -1, -1, -1, -1, -1],
		[7, 3, 2, 6, 7, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
		[2, 3, 11, 10, 6, 8, 10, 8, 9, 8, 6, 7, -1, -1, -1, -1],
		[2, 0, 7, 2, 7, 11, 0, 9, 7, 6, 7, 10, 9, 10, 7, -1],
		[1, 8, 0, 1, 7, 8, 1, 10, 7, 6, 7, 10, 2, 3, 11, -1],
		[11, 2, 1, 11, 1, 7, 10, 6, 1, 6, 7, 1, -1, -1, -1, -1],
		[8, 9, 6, 8, 6, 7, 9, 1, 6, 11, 6, 3, 1, 3, 6, -1],
		[0, 9, 1, 11, 6, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
		[7, 8, 0, 7, 0, 6, 3, 11, 0, 11, 6, 0, -1, -1, -1, -1],
		[7, 11, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
		[7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
		[3, 0, 8, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
		[0, 1, 9, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
		[8, 1, 9, 8, 3, 1, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1],
		[10, 1, 2, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
		[1, 2, 10, 3, 0, 8, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1],
		[2, 9, 0, 2, 10, 9, 6, 11, 7, -1, -1, -1, -1, -1, -1, -1],
		[6, 11, 7, 2, 10, 3, 10, 8, 3, 10, 9, 8, -1, -1, -1, -1],
		[7, 2, 3, 6, 2, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
		[7, 0, 8, 7, 6, 0, 6, 2, 0, -1, -1, -1, -1, -1, -1, -1],
		[2, 7, 6, 2, 3, 7, 0, 1, 9, -1, -1, -1, -1, -1, -1, -1],
		[1, 6, 2, 1, 8, 6, 1, 9, 8, 8, 7, 6, -1, -1, -1, -1],
		[10, 7, 6, 10, 1, 7, 1, 3, 7, -1, -1, -1, -1, -1, -1, -1],
		[10, 7, 6, 1, 7, 10, 1, 8, 7, 1, 0, 8, -1, -1, -1, -1],
		[0, 3, 7, 0, 7, 10, 0, 10, 9, 6, 10, 7, -1, -1, -1, -1],
		[7, 6, 10, 7, 10, 8, 8, 10, 9, -1, -1, -1, -1, -1, -1, -1],
		[6, 8, 4, 11, 8, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
		[3, 6, 11, 3, 0, 6, 0, 4, 6, -1, -1, -1, -1, -1, -1, -1],
		[8, 6, 11, 8, 4, 6, 9, 0, 1, -1, -1, -1, -1, -1, -1, -1],
		[9, 4, 6, 9, 6, 3, 9, 3, 1, 11, 3, 6, -1, -1, -1, -1],
		[6, 8, 4, 6, 11, 8, 2, 10, 1, -1, -1, -1, -1, -1, -1, -1],
		[1, 2, 10, 3, 0, 11, 0, 6, 11, 0, 4, 6, -1, -1, -1, -1],
		[4, 11, 8, 4, 6, 11, 0, 2, 9, 2, 10, 9, -1, -1, -1, -1],
		[10, 9, 3, 10, 3, 2, 9, 4, 3, 11, 3, 6, 4, 6, 3, -1],
		[8, 2, 3, 8, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1],
		[0, 4, 2, 4, 6, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
		[1, 9, 0, 2, 3, 4, 2, 4, 6, 4, 3, 8, -1, -1, -1, -1],
		[1, 9, 4, 1, 4, 2, 2, 4, 6, -1, -1, -1, -1, -1, -1, -1],
		[8, 1, 3, 8, 6, 1, 8, 4, 6, 6, 10, 1, -1, -1, -1, -1],
		[10, 1, 0, 10, 0, 6, 6, 0, 4, -1, -1, -1, -1, -1, -1, -1],
		[4, 6, 3, 4, 3, 8, 6, 10, 3, 0, 3, 9, 10, 9, 3, -1],
		[10, 9, 4, 6, 10, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
		[4, 9, 5, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
		[0, 8, 3, 4, 9, 5, 11, 7, 6, -1, -1, -1, -1, -1, -1, -1],
		[5, 0, 1, 5, 4, 0, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1],
		[11, 7, 6, 8, 3, 4, 3, 5, 4, 3, 1, 5, -1, -1, -1, -1],
		[9, 5, 4, 10, 1, 2, 7, 6, 11, -1, -1, -1, -1, -1, -1, -1],
		[6, 11, 7, 1, 2, 10, 0, 8, 3, 4, 9, 5, -1, -1, -1, -1],
		[7, 6, 11, 5, 4, 10, 4, 2, 10, 4, 0, 2, -1, -1, -1, -1],
		[3, 4, 8, 3, 5, 4, 3, 2, 5, 10, 5, 2, 11, 7, 6, -1],
		[7, 2, 3, 7, 6, 2, 5, 4, 9, -1, -1, -1, -1, -1, -1, -1],
		[9, 5, 4, 0, 8, 6, 0, 6, 2, 6, 8, 7, -1, -1, -1, -1],
		[3, 6, 2, 3, 7, 6, 1, 5, 0, 5, 4, 0, -1, -1, -1, -1],
		[6, 2, 8, 6, 8, 7, 2, 1, 8, 4, 8, 5, 1, 5, 8, -1],
		[9, 5, 4, 10, 1, 6, 1, 7, 6, 1, 3, 7, -1, -1, -1, -1],
		[1, 6, 10, 1, 7, 6, 1, 0, 7, 8, 7, 0, 9, 5, 4, -1],
		[4, 0, 10, 4, 10, 5, 0, 3, 10, 6, 10, 7, 3, 7, 10, -1],
		[7, 6, 10, 7, 10, 8, 5, 4, 10, 4, 8, 10, -1, -1, -1, -1],
		[6, 9, 5, 6, 11, 9, 11, 8, 9, -1, -1, -1, -1, -1, -1, -1],
		[3, 6, 11, 0, 6, 3, 0, 5, 6, 0, 9, 5, -1, -1, -1, -1],
		[0, 11, 8, 0, 5, 11, 0, 1, 5, 5, 6, 11, -1, -1, -1, -1],
		[6, 11, 3, 6, 3, 5, 5, 3, 1, -1, -1, -1, -1, -1, -1, -1],
		[1, 2, 10, 9, 5, 11, 9, 11, 8, 11, 5, 6, -1, -1, -1, -1],
		[0, 11, 3, 0, 6, 11, 0, 9, 6, 5, 6, 9, 1, 2, 10, -1],
		[11, 8, 5, 11, 5, 6, 8, 0, 5, 10, 5, 2, 0, 2, 5, -1],
		[6, 11, 3, 6, 3, 5, 2, 10, 3, 10, 5, 3, -1, -1, -1, -1],
		[5, 8, 9, 5, 2, 8, 5, 6, 2, 3, 8, 2, -1, -1, -1, -1],
		[9, 5, 6, 9, 6, 0, 0, 6, 2, -1, -1, -1, -1, -1, -1, -1],
		[1, 5, 8, 1, 8, 0, 5, 6, 8, 3, 8, 2, 6, 2, 8, -1],
		[1, 5, 6, 2, 1, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
		[1, 3, 6, 1, 6, 10, 3, 8, 6, 5, 6, 9, 8, 9, 6, -1],
		[10, 1, 0, 10, 0, 6, 9, 5, 0, 5, 6, 0, -1, -1, -1, -1],
		[0, 3, 8, 5, 6, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
		[10, 5, 6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
		[11, 5, 10, 7, 5, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
		[11, 5, 10, 11, 7, 5, 8, 3, 0, -1, -1, -1, -1, -1, -1, -1],
		[5, 11, 7, 5, 10, 11, 1, 9, 0, -1, -1, -1, -1, -1, -1, -1],
		[10, 7, 5, 10, 11, 7, 9, 8, 1, 8, 3, 1, -1, -1, -1, -1],
		[11, 1, 2, 11, 7, 1, 7, 5, 1, -1, -1, -1, -1, -1, -1, -1],
		[0, 8, 3, 1, 2, 7, 1, 7, 5, 7, 2, 11, -1, -1, -1, -1],
		[9, 7, 5, 9, 2, 7, 9, 0, 2, 2, 11, 7, -1, -1, -1, -1],
		[7, 5, 2, 7, 2, 11, 5, 9, 2, 3, 2, 8, 9, 8, 2, -1],
		[2, 5, 10, 2, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1],
		[8, 2, 0, 8, 5, 2, 8, 7, 5, 10, 2, 5, -1, -1, -1, -1],
		[9, 0, 1, 5, 10, 3, 5, 3, 7, 3, 10, 2, -1, -1, -1, -1],
		[9, 8, 2, 9, 2, 1, 8, 7, 2, 10, 2, 5, 7, 5, 2, -1],
		[1, 3, 5, 3, 7, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
		[0, 8, 7, 0, 7, 1, 1, 7, 5, -1, -1, -1, -1, -1, -1, -1],
		[9, 0, 3, 9, 3, 5, 5, 3, 7, -1, -1, -1, -1, -1, -1, -1],
		[9, 8, 7, 5, 9, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
		[5, 8, 4, 5, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1],
		[5, 0, 4, 5, 11, 0, 5, 10, 11, 11, 3, 0, -1, -1, -1, -1],
		[0, 1, 9, 8, 4, 10, 8, 10, 11, 10, 4, 5, -1, -1, -1, -1],
		[10, 11, 4, 10, 4, 5, 11, 3, 4, 9, 4, 1, 3, 1, 4, -1],
		[2, 5, 1, 2, 8, 5, 2, 11, 8, 4, 5, 8, -1, -1, -1, -1],
		[0, 4, 11, 0, 11, 3, 4, 5, 11, 2, 11, 1, 5, 1, 11, -1],
		[0, 2, 5, 0, 5, 9, 2, 11, 5, 4, 5, 8, 11, 8, 5, -1],
		[9, 4, 5, 2, 11, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
		[2, 5, 10, 3, 5, 2, 3, 4, 5, 3, 8, 4, -1, -1, -1, -1],
		[5, 10, 2, 5, 2, 4, 4, 2, 0, -1, -1, -1, -1, -1, -1, -1],
		[3, 10, 2, 3, 5, 10, 3, 8, 5, 4, 5, 8, 0, 1, 9, -1],
		[5, 10, 2, 5, 2, 4, 1, 9, 2, 9, 4, 2, -1, -1, -1, -1],
		[8, 4, 5, 8, 5, 3, 3, 5, 1, -1, -1, -1, -1, -1, -1, -1],
		[0, 4, 5, 1, 0, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
		[8, 4, 5, 8, 5, 3, 9, 0, 5, 0, 3, 5, -1, -1, -1, -1],
		[9, 4, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
		[4, 11, 7, 4, 9, 11, 9, 10, 11, -1, -1, -1, -1, -1, -1, -1],
		[0, 8, 3, 4, 9, 7, 9, 11, 7, 9, 10, 11, -1, -1, -1, -1],
		[1, 10, 11, 1, 11, 4, 1, 4, 0, 7, 4, 11, -1, -1, -1, -1],
		[3, 1, 4, 3, 4, 8, 1, 10, 4, 7, 4, 11, 10, 11, 4, -1],
		[4, 11, 7, 9, 11, 4, 9, 2, 11, 9, 1, 2, -1, -1, -1, -1],
		[9, 7, 4, 9, 11, 7, 9, 1, 11, 2, 11, 1, 0, 8, 3, -1],
		[11, 7, 4, 11, 4, 2, 2, 4, 0, -1, -1, -1, -1, -1, -1, -1],
		[11, 7, 4, 11, 4, 2, 8, 3, 4, 3, 2, 4, -1, -1, -1, -1],
		[2, 9, 10, 2, 7, 9, 2, 3, 7, 7, 4, 9, -1, -1, -1, -1],
		[9, 10, 7, 9, 7, 4, 10, 2, 7, 8, 7, 0, 2, 0, 7, -1],
		[3, 7, 10, 3, 10, 2, 7, 4, 10, 1, 10, 0, 4, 0, 10, -1],
		[1, 10, 2, 8, 7, 4, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
		[4, 9, 1, 4, 1, 7, 7, 1, 3, -1, -1, -1, -1, -1, -1, -1],
		[4, 9, 1, 4, 1, 7, 0, 8, 1, 8, 7, 1, -1, -1, -1, -1],
		[4, 0, 3, 7, 4, 3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
		[4, 8, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
		[9, 10, 8, 10, 11, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
		[3, 0, 9, 3, 9, 11, 11, 9, 10, -1, -1, -1, -1, -1, -1, -1],
		[0, 1, 10, 0, 10, 8, 8, 10, 11, -1, -1, -1, -1, -1, -1, -1],
		[3, 1, 10, 11, 3, 10, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
		[1, 2, 11, 1, 11, 9, 9, 11, 8, -1, -1, -1, -1, -1, -1, -1],
		[3, 0, 9, 3, 9, 11, 1, 2, 9, 2, 11, 9, -1, -1, -1, -1],
		[0, 2, 11, 8, 0, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
		[3, 2, 11, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
		[2, 3, 8, 2, 8, 10, 10, 8, 9, -1, -1, -1, -1, -1, -1, -1],
		[9, 10, 2, 0, 9, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
		[2, 3, 8, 2, 8, 10, 0, 1, 8, 1, 10, 8, -1, -1, -1, -1],
		[1, 10, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
		[1, 3, 8, 9, 1, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
		[0, 9, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
		[0, 3, 8, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1],
		[-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1]
	]

@export var brush_radius := 2.0
@export var current_brush_type := BrushType.MODIFY
@export var RESOLUTION: int = 64 #128 or maybe 256
@export var ISO_LEVEL := 0.0
@export var USE_NOISE := true
@export var NOISE: FastNoiseLite
@export var FLAT_GROUND_LEVEL := 10
@export var FLAT_SHADED := false
@export var TERRAIN_TERRACE: int = 1
@export var terrain_material : Material
@export var wall_material: Material
@export var show_preview := true
@export var CHUNK_SIZE := 16 #lower if nmeed for bigger resolution
@export var preview_material : Material

@export var regenerate_in_editor := false:
	set(value):
		if value:
			#regenerate_in_editor = false
			if Engine.is_editor_hint():
				print("Generating terrain in editor...")
				clear_chunks()
				initialize_voxel_data()
				generate_all_chunks()
				create_all_collision_shapes()
				create_terrain_border()
			
@export var delete_terrain_in_editor := false:
	set(value):
		if value and Engine.is_editor_hint():
			print(" Deleting terrain in editor...")
			clear_chunks()

var brush_strength := 5.0
var voxel_data: PackedFloat32Array
var mesh_instance: MeshInstance3D
var static_body: StaticBody3D

#const CHUNK_SIZE = 16
var chunks = {}
var chunk_mesh_instances = {}
var chunk_static_bodies = {}
var dirty_chunks: = {}

var preview_voxel_data: PackedFloat32Array
var preview_mesh_instances := {}
var last_preview_voxel_pos: Vector3 = Vector3(-1, -1, -1)
var current_preview_keys := []
var preview_chunks_to_update := []
var current_brush_shape: BrushShape = BrushShape.SPHERE

signal terrain_ready

enum BrushType {
	MODIFY,
	DIG,
	FLAT_SQUARE,
	EQUALIZE
}
enum BrushShape { SPHERE, CUBE, CONE }

var time_since_mouse_still := 0.0
var last_stable_mouse_pos: Vector3 = Vector3(-1, -1, -1)
const PREVIEW_DELAY := 0.05

var brush_applier := BrushApplier.new()

# === CONFIGURABLE ===
var max_threads: int = 4  # Optimal: 2-4 threads for CPU-bound work (avoid context switching overhead)
@export var chunks_per_frame: int = 5  # Process this many chunks per frame

# === INTERNAL STATE ===
var chunk_queue: Array = []
var threads: Array = []
var thread_mutex := Mutex.new()
var mesh_queue: Array = []  # Queue for completed meshes from threads
var mesh_queue_mutex := Mutex.new()

var finalize_total_time := 0  # Add this as a class-level variable
var finalize_count := 0

func _ready():
	setup_nodes()
	call_deferred("_start_generation_thread")

func _start_generation():
	initialize_voxel_data_thread()
	preview_voxel_data = PackedFloat32Array()
	preview_voxel_data.resize(voxel_data.size())

	generate_all_chunks()
	create_all_collision_shapes()
	create_terrain_border()

	add_child(brush_applier)
	brush_applier.connect("brush_done", Callable(self, "_on_brush_done"))
	brush_applier.connect("chunk_mesh_ready", Callable(self, "_on_chunk_mesh_ready"))

	emit_signal("terrain_ready")
	
func _start_generation_thread():
	var separator = "=".repeat(60)
	print(separator)
	print("TERRAIN GENERATION STARTED")
	print(separator)
	var logical_cores = OS.get_processor_count()
	
	# For CPU-bound marching cubes, fewer threads is often better
	# Too many threads = context switching overhead and cache thrashing
	# Optimal is usually 2-4 threads for this type of work
	# Only auto-adjust if user hasn't customized it
	if max_threads == 4:  # Default value
		# Use physical cores (estimate: logical cores / 2) or 4, whichever is smaller
		var estimated_physical_cores = max(2, logical_cores / 2)
		max_threads = min(4, max(2, int(estimated_physical_cores)))
	
	print(" Logical CPU cores: ", logical_cores)
	print(" Max threads used: ", max_threads, " (optimal for CPU-bound work)")
	print(" Resolution: ", RESOLUTION, "x", RESOLUTION, "x", RESOLUTION)
	print(" Chunk size: ", CHUNK_SIZE)
	var total_chunks = pow(int(RESOLUTION / CHUNK_SIZE), 3)
	print(" Total chunks: ", total_chunks)
	print("-".repeat(60))

	var t0 = Time.get_ticks_msec()
	initialize_voxel_data_thread()
	var t1 = Time.get_ticks_msec()
	var voxel_time = t1 - t0
	print(" Voxel data init: ", _format_time(voxel_time))

	preview_voxel_data = PackedFloat32Array()
	preview_voxel_data.resize(voxel_data.size())

	var t2 = Time.get_ticks_msec()
	generate_all_chunks_threaded()
	
	# Wait for all threads to finish generating vertices and building meshes
	var t2_5 = Time.get_ticks_msec()
	print(" Waiting for worker threads to complete...")
	for thread in threads:
		thread.wait_to_finish()
	threads.clear()
	var t2_6 = Time.get_ticks_msec()
	var thread_time = t2_6 - t2_5
	print("   Threads finished in: ", _format_time(thread_time))
	
	# Process all remaining meshes from queue
	var t2_7 = Time.get_ticks_msec()
	print(" Processing remaining meshes from queue...")
	mesh_queue_mutex.lock()
	var total_meshes = mesh_queue.size()
	mesh_queue_mutex.unlock()
	
	var processed = 0
	var mesh_processing_start = Time.get_ticks_msec()
	while true:
		mesh_queue_mutex.lock()
		if mesh_queue.size() == 0:
			mesh_queue_mutex.unlock()
			break
		var item = mesh_queue.pop_front()
		mesh_queue_mutex.unlock()
		
		_finalize_chunk_mesh(item.pos.x, item.pos.y, item.pos.z, item.mesh)
		processed += 1
		
		# Progress update every 10 chunks
		if processed % 10 == 0:
			var elapsed = Time.get_ticks_msec() - mesh_processing_start
			var rate = processed / (elapsed / 1000.0) if elapsed > 0 else 0
			print("   Processed ", processed, " / ", total_meshes, " chunks (", "%.1f" % rate, " chunks/sec)...")
	
	var t3 = Time.get_ticks_msec()
	var mesh_processing_time = t3 - t2_7
	var total_mesh_time = t3 - t2
	print(" Mesh processing: ", _format_time(mesh_processing_time))
	print(" Total chunk generation (threaded): ", _format_time(total_mesh_time))
	print("   Thread work: ", _format_time(thread_time))
	print("   Main thread finalization: ", _format_time(mesh_processing_time))

	var t4 = Time.get_ticks_msec()
	create_terrain_border()
	var t5 = Time.get_ticks_msec()
	var border_time = t5 - t4
	print(" Terrain border creation: ", _format_time(border_time))

	add_child(brush_applier)
	brush_applier.connect("brush_done", Callable(self, "_on_brush_done"))
	brush_applier.connect("chunk_mesh_ready", Callable(self, "_on_chunk_mesh_ready"))

	emit_signal("terrain_ready")

	var total = t5 - t0
	print("-".repeat(60))
	print(" TERRAIN GENERATION COMPLETE")
	print(separator)
	print(" TIMING BREAKDOWN:")
	print("   ├─ Voxel data init:     ", _format_time(voxel_time))
	print("   ├─ Chunk generation:    ", _format_time(total_mesh_time))
	print("   │  ├─ Thread work:      ", _format_time(thread_time))
	print("   │  └─ Mesh finalization: ", _format_time(mesh_processing_time))
	print("   ├─ Terrain border:     ", _format_time(border_time))
	print("   └─ TOTAL TIME:          ", _format_time(total))
	print(separator)
	
	# Calculate performance metrics
	var chunks_per_sec = total_chunks / (total / 1000.0) if total > 0 else 0
	print(" Performance: ", "%.2f" % chunks_per_sec, " chunks/second")
	print(separator)

# Helper function to format time nicely
func _format_time(ms: int) -> String:
	if ms < 1000:
		return str(ms) + " ms"
	else:
		var seconds = ms / 1000.0
		if seconds < 60:
			return "%.2f" % seconds + " sec"
		else:
			var mins = int(seconds / 60)
			var secs = seconds - (mins * 60)
			return str(mins) + "m " + "%.2f" % secs + "s"


var was_moving := false

func process_node(delta):
	# Process mesh queue from threads (incremental processing)
	_process_mesh_queue()
	
	if show_preview:
		var hit_position = get_mouse_world_hit()

		if hit_position != null:
			var mouse_velocity = Input.get_last_mouse_velocity()
			var mouse_is_moving = mouse_velocity.length() > 0.0

			if mouse_is_moving:
				# Clear preview only if movement just started
				if not was_moving:
					clear_preview()
				was_moving = true

				time_since_mouse_still = 0.0
				last_stable_mouse_pos = Vector3(-1, -1, -1)
				return
			else:
				was_moving = false

			# Handle preview delay and updating only when mouse stops moving
			var rounded_pos = Vector3(
				snapped(hit_position.x, 0.001),
				snapped(hit_position.y, 0.001),
				snapped(hit_position.z, 0.001)
			)

			if last_stable_mouse_pos == Vector3(-1, -1, -1) or last_stable_mouse_pos != rounded_pos:
				last_stable_mouse_pos = rounded_pos
				time_since_mouse_still = 0.0
			else:
				time_since_mouse_still += delta
				if time_since_mouse_still >= PREVIEW_DELAY:
					var voxel_pos = to_local(hit_position).floor()
					if voxel_pos != last_preview_voxel_pos or last_preview_voxel_pos == Vector3(-1, -1, -1):
						update_preview(hit_position)
						last_preview_voxel_pos = voxel_pos
	else:
		clear_preview()

	if preview_chunks_to_update.size() > 0:
		var key = preview_chunks_to_update.pop_front()
		var coords = parse_chunk_key(key)
		generate_preview_chunk(coords.x, coords.y, coords.z)

# Process mesh queue incrementally (called from process_node)
# This is used for runtime chunk updates, not initial generation
func _process_mesh_queue():
	# Process chunks_per_frame meshes per frame
	mesh_queue_mutex.lock()
	var processed = 0
	while mesh_queue.size() > 0 and processed < chunks_per_frame:
		var item = mesh_queue.pop_front()
		mesh_queue_mutex.unlock()
		
		_finalize_chunk_mesh(item.pos.x, item.pos.y, item.pos.z, item.mesh)
		processed += 1
		
		mesh_queue_mutex.lock()
	mesh_queue_mutex.unlock()

func setup_nodes():
	for child in get_children():
		if child.name.begins_with("ChunkMesh_") or child.name.begins_with("ChunkStaticBody_"):
			child.queue_free()

func grid_index(x: int, y: int, z: int) -> int:
	return x + RESOLUTION * (y + RESOLUTION * z)

func voxel_write(x: int, y: int, z: int, value: float) -> void:
	voxel_data[grid_index(x, y, z)] = value

func voxel_read(x: int, y: int, z: int, cache: Dictionary) -> float:
	# Fast path for in-bounds reads (most common case)
	if x >= 0 and y >= 0 and z >= 0 and x < RESOLUTION and y < RESOLUTION and z < RESOLUTION:
		var index = x + RESOLUTION * (y + RESOLUTION * z)
		return voxel_data[index]
	
	# Out of bounds - return 0.0 (no need to cache this)
	return 0.0
	
func chunk_key(cx: int, cy: int, cz: int) -> String:
	return str(cx) + "," + str(cy) + "," + str(cz)
	
func parse_chunk_key(key: String) -> Vector3:
	var parts = key.split(",")  # use comma instead of underscore
	if parts.size() < 3:
		push_error("Chunk key format invalid: " + key)
		return Vector3.ZERO
	return Vector3(parts.get(0).to_int(), parts.get(1).to_int(), parts.get(2).to_int())

func initialize_voxel_data():
	var size = RESOLUTION * RESOLUTION * RESOLUTION
	voxel_data = PackedFloat32Array()
	voxel_data.resize(size)
	voxel_data.fill(1.0)

	for x in range(0, RESOLUTION):
		for y in range(0, RESOLUTION):
			for z in range(0, RESOLUTION):
				var value: float

				if USE_NOISE:
					value = NOISE.get_noise_3d(x, y, z) + float(y + y % TERRAIN_TERRACE) / RESOLUTION - 0.5
				else:
					value = 1.0 if y >= FLAT_GROUND_LEVEL else -1.0

				voxel_write(x, y, z, value)

func initialize_voxel_data_thread():
	var size = RESOLUTION * RESOLUTION * RESOLUTION
	voxel_data = PackedFloat32Array()
	voxel_data.resize(size)
	voxel_data.fill(1.0)

	for x in range(RESOLUTION):
		for y in range(RESOLUTION):
			for z in range(RESOLUTION):
				var value: float
				if USE_NOISE:
					value = NOISE.get_noise_3d(x, y, z) + float(y + y % TERRAIN_TERRACE) / RESOLUTION - 0.5
				else:
					value = 1.0 if y >= FLAT_GROUND_LEVEL else -1.0
				voxel_write(x, y, z, value)

func march_cube(x: int, y: int, z: int, verts: PackedVector3Array, voxel_cache: Dictionary, edges: Array, points: Array, triangulations: Array):
	var tri = get_triangulation(x, y, z, voxel_cache, triangulations)
	for edge_index in tri:
		if edge_index < 0:
			break
		var edge = edges[edge_index]
		var a = points[edge.x]
		var b = points[edge.y]

		var pos_a = Vector3(x + a.x, y + a.y, z + a.z)
		var pos_b = Vector3(x + b.x, y + b.y, z + b.z)

		var interp = calculate_interpolation(pos_a, pos_b, voxel_cache)
		verts.append(interp)
		
func generate_all_chunks():
	var chunks_per_axis = int(RESOLUTION / CHUNK_SIZE)
	for cx in range(chunks_per_axis):
		for cy in range(chunks_per_axis):
			for cz in range(chunks_per_axis):
				generate_chunk(cx, cy, cz)

func generate_chunk(cx: int, cy: int, cz: int):
	var local_edges = MarchingCubeData.edges
	var local_points = MarchingCubeData.points
	var local_triangulations = MarchingCubeData.triangulations
	
	var vertices = PackedVector3Array()
	var voxel_cache := {}

	var start_x = cx * CHUNK_SIZE
	var start_y = cy * CHUNK_SIZE
	var start_z = cz * CHUNK_SIZE

	var end_x = min(RESOLUTION - 1, start_x + CHUNK_SIZE)
	var end_y = min(RESOLUTION - 1, start_y + CHUNK_SIZE)
	var end_z = min(RESOLUTION - 1, start_z + CHUNK_SIZE)

	for x in range(start_x, end_x):
		for y in range(start_y, end_y):
			for z in range(start_z, end_z):
				march_cube(x, y, z, vertices, voxel_cache, local_edges, local_points, local_triangulations)  # <-- pass cache
	
	if vertices.is_empty():
		return

	var st = SurfaceTool.new()
	st.begin(Mesh.PRIMITIVE_TRIANGLES)

	if FLAT_SHADED:
		st.set_smooth_group(-1)

	for v in vertices:
		st.add_vertex(v)

	st.generate_normals()
	st.index()
	st.set_material(terrain_material)
	var mesh = st.commit()

	var key = chunk_key(cx, cy, cz)
	
	var mesh_instance_new_chunk: MeshInstance3D

	if not chunk_mesh_instances.has(key):
		mesh_instance_new_chunk = MeshInstance3D.new()
		mesh_instance_new_chunk.name = "ChunkMesh_" + key
		add_child(mesh_instance_new_chunk)
		mesh_instance_new_chunk.owner = self.owner
		chunk_mesh_instances[key] = mesh_instance_new_chunk
	else:
		mesh_instance_new_chunk = chunk_mesh_instances[key]

	mesh_instance_new_chunk.mesh = mesh

	create_chunk_collision(cx, cy, cz)
	
func generate_all_chunks_threaded():
	var chunk_list = []
	var chunks_per_axis = int(RESOLUTION / CHUNK_SIZE)
	for cx in range(chunks_per_axis):
		for cy in range(chunks_per_axis):
			for cz in range(chunks_per_axis):
				chunk_list.append(Vector3i(cx, cy, cz))

	# Distribute evenly to threads
	var chunk_batches = []
	for i in range(max_threads):
		chunk_batches.append([])

	for i in range(chunk_list.size()):
		chunk_batches[i % max_threads].append(chunk_list[i])

	print(" Spawning ", max_threads, " worker threads")
	for i in range(max_threads):
		var thread := Thread.new()
		var bound_callable = Callable(self, "_chunk_worker_thread").bind(chunk_batches[i])
		var status = thread.start(bound_callable)
		threads.append(thread)
	
	# Don't wait for threads - let them finish in background
	# Process mesh queue incrementally in process_node
	
func _chunk_worker_thread(chunk_list: Array):
	var local_edges = MarchingCubeData.edges
	var local_points = MarchingCubeData.points
	var local_triangulations = MarchingCubeData.triangulations

	var t_start = Time.get_ticks_usec()
	var vertex_time = 0
	var mesh_time = 0
	var vertex_count = 0
	var mesh_count = 0

	for pos in chunk_list:
		var v_start = Time.get_ticks_usec()
		var vertices := generate_chunk_vertices(pos.x, pos.y, pos.z, local_edges, local_points, local_triangulations)
		vertex_time += Time.get_ticks_usec() - v_start
		vertex_count += vertices.size()
		
		if not vertices.is_empty():
			var m_start = Time.get_ticks_usec()
			# Build mesh in thread (SurfaceTool is thread-safe for building)
			var mesh = _build_mesh_in_thread(vertices)
			mesh_time += Time.get_ticks_usec() - m_start
			mesh_count += 1
			
			if mesh:
				# Queue the mesh for main thread processing
				mesh_queue_mutex.lock()
				mesh_queue.append({"pos": pos, "mesh": mesh})
				mesh_queue_mutex.unlock()

	var t_end = Time.get_ticks_usec()
	var elapsed_ms = (t_end - t_start) / 1000.0
	var avg_chunk_time = elapsed_ms / chunk_list.size() if chunk_list.size() > 0 else 0
	print(" Worker thread: ", "%.1f" % elapsed_ms, " ms (", chunk_list.size(), " chunks, ", "%.1f" % avg_chunk_time, " ms/chunk)")
	print("   ├─ Vertex gen: ", "%.1f" % (vertex_time / 1000.0), " ms (", vertex_count, " vertices)")
	print("   └─ Mesh build: ", "%.1f" % (mesh_time / 1000.0), " ms (", mesh_count, " meshes)")
			
func generate_chunk_vertices(cx: int, cy: int, cz: int, edges: Array, points: Array, triangulations: Array) -> PackedVector3Array:
	var vertices = PackedVector3Array()
	var voxel_cache := {}

	var start_x = cx * CHUNK_SIZE
	var start_y = cy * CHUNK_SIZE
	var start_z = cz * CHUNK_SIZE

	var end_x = min(RESOLUTION - 1, start_x + CHUNK_SIZE)
	var end_y = min(RESOLUTION - 1, start_y + CHUNK_SIZE)
	var end_z = min(RESOLUTION - 1, start_z + CHUNK_SIZE)
	
	for x in range(start_x, end_x):
		for y in range(start_y, end_y):
			for z in range(start_z, end_z):
				march_cube(x, y, z, vertices, voxel_cache, edges, points, triangulations)

	return vertices

# Build mesh in thread - SurfaceTool operations are thread-safe
func _build_mesh_in_thread(vertices: PackedVector3Array) -> ArrayMesh:
	if vertices.is_empty():
		return null
	
	var st = SurfaceTool.new()
	st.begin(Mesh.PRIMITIVE_TRIANGLES)
	if FLAT_SHADED:
		st.set_smooth_group(-1)
	
	for v in vertices:
		st.add_vertex(v)
	
	st.generate_normals()
	st.index()
	st.set_material(terrain_material)
	return st.commit()

# Removed - mesh building now happens in threads

func _finalize_chunk_mesh(cx: int, cy: int, cz: int, mesh: ArrayMesh):
	var key = chunk_key(cx, cy, cz)
	var mesh_instance: MeshInstance3D

	if not chunk_mesh_instances.has(key):
		mesh_instance = MeshInstance3D.new()
		mesh_instance.name = "ChunkMesh_" + key
		add_child(mesh_instance)
		mesh_instance.owner = self.owner
		chunk_mesh_instances[key] = mesh_instance
	else:
		mesh_instance = chunk_mesh_instances[key]

	mesh_instance.mesh = mesh
	# Create collision immediately (we're processing in batches, so this is fine)
	create_chunk_collision(cx, cy, cz)

func create_chunk_collision(cx: int, cy: int, cz: int):
	var key = chunk_key(cx, cy, cz)

	if chunk_static_bodies.has(key):
		chunk_static_bodies[key].queue_free()

	var static_body_chunk = StaticBody3D.new()
	static_body_chunk.name = "ChunkStaticBody_" + key
	add_child(static_body_chunk)
	static_body_chunk.owner = self.owner
	chunk_static_bodies[key] = static_body_chunk

	var collision_shape = CollisionShape3D.new()
	collision_shape.name = "CollisionShape3D"
	static_body_chunk.add_child(collision_shape)
	collision_shape.owner = self.owner

	# Get mesh from chunk mesh instance
	var mesh_instance_chunk = chunk_mesh_instances[key]
	if not mesh_instance_chunk or not mesh_instance_chunk.mesh:
		print("No mesh for collision for chunk ", key)
		return

	var arrays = mesh_instance_chunk.mesh.surface_get_arrays(0)
	if arrays.size() == 0:
		print("Mesh has no surfaces for chunk ", key)
		return

	var vertices: PackedVector3Array = arrays[Mesh.ARRAY_VERTEX]
	var indices: PackedInt32Array = arrays[Mesh.ARRAY_INDEX]

	var shape = ConcavePolygonShape3D.new()
	if indices.size() > 0:
		var faces = PackedVector3Array()
		for i in range(0, indices.size(), 3):
			faces.append(vertices[indices[i]])
			faces.append(vertices[indices[i + 1]])
			faces.append(vertices[indices[i + 2]])
		shape.set_faces(faces)
	else:
		shape.set_faces(vertices)

	collision_shape.call_deferred("set", "shape", shape)

func calculate_interpolation(a: Vector3, b: Vector3, cache: Dictionary) -> Vector3:
	var is_a_voxel_center = a.floor() == a
	var is_b_voxel_center = b.floor() == b

	var val_a = voxel_read(int(a.x), int(a.y), int(a.z), cache) if is_a_voxel_center else voxel_trilinear(a, cache)
	var val_b = voxel_read(int(b.x), int(b.y), int(b.z), cache) if is_b_voxel_center else voxel_trilinear(b, cache)

	var denom = val_b - val_a
	if abs(denom) < 0.0001:
		return a
	var t = (ISO_LEVEL - val_a) / denom
	return a + t * (b - a)

func voxel_trilinear(pos: Vector3, cache: Dictionary) -> float:
	var x0 = clamp(int(floor(pos.x)), 0, RESOLUTION - 2)
	var y0 = clamp(int(floor(pos.y)), 0, RESOLUTION - 2)
	var z0 = clamp(int(floor(pos.z)), 0, RESOLUTION - 2)
	var x1 = x0 + 1
	var y1 = y0 + 1
	var z1 = z0 + 1

	var dx = pos.x - x0
	var dy = pos.y - y0
	var dz = pos.z - z0

	var c000 = voxel_read(x0, y0, z0, cache)
	var c100 = voxel_read(x1, y0, z0, cache)
	var c010 = voxel_read(x0, y1, z0, cache)
	var c110 = voxel_read(x1, y1, z0, cache)
	var c001 = voxel_read(x0, y0, z1, cache)
	var c101 = voxel_read(x1, y0, z1, cache)
	var c011 = voxel_read(x0, y1, z1, cache)
	var c111 = voxel_read(x1, y1, z1, cache)

	var c00 = lerp(c000, c100, dx)
	var c10 = lerp(c010, c110, dx)
	var c01 = lerp(c001, c101, dx)
	var c11 = lerp(c011, c111, dx)

	var c0 = lerp(c00, c10, dy)
	var c1 = lerp(c01, c11, dy)

	return lerp(c0, c1, dz)

func get_triangulation(x: int, y: int, z: int, cache: Dictionary, triangulations: Array) -> Array:
	var idx = 0
	idx |= int(voxel_read(x, y, z, cache) < ISO_LEVEL) << 0
	idx |= int(voxel_read(x, y, z + 1, cache) < ISO_LEVEL) << 1
	idx |= int(voxel_read(x + 1, y, z + 1, cache) < ISO_LEVEL) << 2
	idx |= int(voxel_read(x + 1, y, z, cache) < ISO_LEVEL) << 3
	idx |= int(voxel_read(x, y + 1, z, cache) < ISO_LEVEL) << 4
	idx |= int(voxel_read(x, y + 1, z + 1, cache) < ISO_LEVEL) << 5
	idx |= int(voxel_read(x + 1, y + 1, z + 1, cache) < ISO_LEVEL) << 6
	idx |= int(voxel_read(x + 1, y + 1, z, cache) < ISO_LEVEL) << 7
	return triangulations[idx]

func create_collision_shape():
	if not mesh_instance.mesh:
		print("No mesh to generate collision from.")
		return

	var arrays = mesh_instance.mesh.surface_get_arrays(0)
	if arrays.size() == 0:
		print("Mesh has no surfaces.")
		return

	var vertices: PackedVector3Array = arrays[Mesh.ARRAY_VERTEX]
	var indices: PackedInt32Array = arrays[Mesh.ARRAY_INDEX]

	var shape = ConcavePolygonShape3D.new()
	if indices.size() > 0:
		var faces = PackedVector3Array()
		for i in range(0, indices.size(), 3):
			faces.append(vertices[indices[i]])
			faces.append(vertices[indices[i + 1]])
			faces.append(vertices[indices[i + 2]])
		shape.set_faces(faces)
	else:
		shape.set_faces(vertices)

	# Clear old
	for child in get_children():
		if child is StaticBody3D:
			child.queue_free()

	# Add new
	static_body = StaticBody3D.new()
	static_body.name = "StaticBody3D"
	add_child(static_body)
	static_body.owner = self.owner

	var collision_shape = CollisionShape3D.new()
	collision_shape.name = "CollisionShape3D"
	collision_shape.shape = shape
	static_body.add_child(collision_shape)
	collision_shape.owner = self.owner


func apply_brush(world_position: Vector3):
	var voxel_pos = to_local(world_position).floor()
	var half = int(brush_radius)

	brush_applier.apply_brush_threaded(
			voxel_data,
			RESOLUTION,
			CHUNK_SIZE,
			ISO_LEVEL,
			Vector3i(voxel_pos),
			half,
			brush_strength,
			current_brush_type,
			current_brush_shape,
			terrain_material
		)

	#match current_brush_type:
		#BrushType.MODIFY:
			#apply_modify_brush(voxel_pos, half)
		#BrushType.DIG:
			#apply_dig_brush(voxel_pos, half)
		#BrushType.FLAT_SQUARE:
			#apply_flat_square_brush(voxel_pos, half)
		#BrushType.EQUALIZE:
			#apply_equalize_brush(voxel_pos, half)
#
	#update_affected_chunks()
				
func apply_modify_brush(voxel_pos: Vector3, half: int):
	var voxels_to_modify: Array[Vector3i] = []

	for x in range(voxel_pos.x - half, voxel_pos.x + half + 1):
		if x < 0 or x >= RESOLUTION: continue
		for y in range(voxel_pos.y - half, voxel_pos.y + half + 1):
			if y < 0 or y >= RESOLUTION: continue
			for z in range(voxel_pos.z - half, voxel_pos.z + half + 1):
				if z < 0 or z >= RESOLUTION: continue

				var local_voxel = Vector3(x, y, z)
				if is_voxel_in_brush_shape(local_voxel, voxel_pos):
					voxels_to_modify.append(Vector3i(x, y, z))

	for voxel in voxels_to_modify:
		var index = voxel.x + RESOLUTION * (voxel.y + RESOLUTION * voxel.z)
		mark_dirty_chunks_around_voxel(voxel)
		match current_brush_shape:
			BrushShape.CUBE:
				voxel_data[index] -= brush_strength
			_:
				var distance = voxel_pos.distance_to(Vector3(voxel))
				var falloff = 1.0 - distance / brush_radius
				if falloff > 0:
					voxel_data[index] -= brush_strength * falloff

func apply_dig_brush(voxel_pos: Vector3, half: int):
	for x in range(voxel_pos.x - half, voxel_pos.x + half + 1):
		if x < 0 or x >= RESOLUTION: continue
		for y in range(voxel_pos.y - half, voxel_pos.y + half + 1):
			if y < 0 or y >= RESOLUTION: continue
			for z in range(voxel_pos.z - half, voxel_pos.z + half + 1):
				if z < 0 or z >= RESOLUTION: continue
				var local_voxel = Vector3(x, y, z)
				if not is_voxel_in_brush_shape(local_voxel, voxel_pos): continue

				var index = x + RESOLUTION * (y + RESOLUTION * z)
				#mark_dirty_chunks_around_voxel(Vector3i(x, y, z))
				match current_brush_shape:
					BrushShape.CUBE:
						voxel_data[index] += brush_strength
					_:
						var distance = voxel_pos.distance_to(local_voxel)
						var falloff = clamp(1.0 - distance / brush_radius, 0.0, 1.0)
						voxel_data[index] += brush_strength * falloff

func apply_flat_square_brush(voxel_pos: Vector3, half: int):
	var platform_value = 1.0  # or any height value you want (like solid ground)

	var center_x = int(voxel_pos.x)
	var center_y = int(voxel_pos.y)
	var center_z = int(voxel_pos.z)

	for x in range(center_x - half, center_x + half):
		if x < 0 or x >= RESOLUTION:
			continue
		for z in range(center_z - half, center_z + half):
			if z < 0 or z >= RESOLUTION:
				continue
			var index = x + RESOLUTION * (center_y + RESOLUTION * z)
			#mark_dirty_chunks_around_voxel(Vector3i(x, center_y, z))
			voxel_data[index] = platform_value

func apply_equalize_brush(voxel_pos: Vector3, half: int):
	var sum := 0.0
	var count := 0

	var center_x = int(voxel_pos.x)
	var center_y = int(voxel_pos.y)
	var center_z = int(voxel_pos.z)

	# First pass: calculate average
	for x in range(center_x - half, center_x + half):
		if x < 0 or x >= RESOLUTION: continue
		for z in range(center_z - half, center_z + half):
			if z < 0 or z >= RESOLUTION: continue
			var index = x + RESOLUTION * (center_y + RESOLUTION * z)
			sum += voxel_data[index]
			count += 1

	if count == 0:
		return

	var average = sum / count

	# Second pass: apply average
	for x in range(center_x - half, center_x + half):
		if x < 0 or x >= RESOLUTION: continue
		for z in range(center_z - half, center_z + half):
			if z < 0 or z >= RESOLUTION: continue
			var index = x + RESOLUTION * (center_y + RESOLUTION * z)
			#mark_dirty_chunks_around_voxel(Vector3i(x, center_y, z))
			voxel_data[index] = average

func is_voxel_in_brush_shape(local_voxel: Vector3, center: Vector3) -> bool:
	var voxel_center = local_voxel + Vector3(0.5, 0.5, 0.5)
	var center_pos = center + Vector3(0.5, 0.5, 0.5)
	var distance = voxel_center.distance_to(center_pos)
	match current_brush_shape:
		BrushShape.SPHERE:
			var inside = distance <= brush_radius
			return inside
		BrushShape.CUBE:
			var dx = abs(local_voxel.x - center.x)
			var dy = abs(local_voxel.y - center.y)
			var dz = abs(local_voxel.z - center.z)
			var half = brush_radius * 0.5  # Use true half-size, not int()
			return dx <= half and dy <= half and dz <= half
		BrushShape.CONE:
			var dz = abs(local_voxel.z - center.z)
			var height = brush_radius
			var cone_radius = brush_radius * (1.0 - dz / height)
			var horizontal_dist = Vector2(local_voxel.x, local_voxel.y).distance_to(Vector2(center.x, center.y))
			return dz <= height and horizontal_dist <= cone_radius
	return false

#func update_affected_chunks():
	#var chunk_array := []
	#for chunk_pos in dirty_chunks.keys():
		#chunk_array.append(chunk_pos)
	#chunk_mesher.start_threaded_meshing(chunk_array)
	#dirty_chunks.clear()
func update_affected_chunks():
	for chunk_pos in dirty_chunks.keys():
		generate_chunk(chunk_pos.x, chunk_pos.y, chunk_pos.z)
	dirty_chunks.clear()

func create_all_collision_shapes():
	for chunk in get_children():
		if chunk is Node3D and chunk.has_node("MeshInstance3D"):
			var mesh_instance_shape_colli := chunk.get_node("MeshInstance3D") as MeshInstance3D
			var mesh := mesh_instance_shape_colli.mesh
			if not mesh:
				print("Chunk has no mesh.")
				continue

			var arrays = mesh.surface_get_arrays(0)
			if arrays.size() == 0:
				print("Mesh has no surface arrays.")
				continue

			var vertices: PackedVector3Array = arrays[Mesh.ARRAY_VERTEX]
			var indices: PackedInt32Array = arrays[Mesh.ARRAY_INDEX]

			var shape = ConcavePolygonShape3D.new()
			if indices.size() > 0:
				var faces = PackedVector3Array()
				for i in range(0, indices.size(), 3):
					faces.append(vertices[indices[i]])
					faces.append(vertices[indices[i + 1]])
					faces.append(vertices[indices[i + 2]])
				shape.set_faces(faces)
			else:
				shape.set_faces(vertices)

			# Remove existing StaticBody3D (if any)
			if chunk.has_node("StaticBody3D"):
				chunk.get_node("StaticBody3D").queue_free()

			var static_body_chunk := StaticBody3D.new()
			static_body_chunk.name = "StaticBody3D"
			chunk.add_child(static_body_chunk)
			static_body_chunk.owner = self.owner

			var collision_shape := CollisionShape3D.new()
			collision_shape.name = "CollisionShape3D"
			collision_shape.shape = shape
			static_body_chunk.add_child(collision_shape)
			collision_shape.owner = self.owner

func create_terrain_border():
	var terrain_size = (RESOLUTION - 1) * 1.0  # Assuming 1 unit per voxel
	var half_size = terrain_size * 0.5

	var wall_height = RESOLUTION + 5.0  # Add a bit extra so player can’t jump out
	var border_thickness = 2.0

	var wall_positions = [
		Vector3(half_size, wall_height * 0.5, -border_thickness * 0.5),  # front
		Vector3(half_size, wall_height * 0.5, terrain_size + border_thickness * 0.5),  # back
		Vector3(-border_thickness * 0.5, wall_height * 0.5, half_size),  # left
		Vector3(terrain_size + border_thickness * 0.5, wall_height * 0.5, half_size)  # right
	]

	var wall_scales = [
		Vector3(terrain_size, wall_height, border_thickness),
		Vector3(terrain_size, wall_height, border_thickness),
		Vector3(border_thickness, wall_height, terrain_size),
		Vector3(border_thickness, wall_height, terrain_size)
	]

	for i in range(4):
		var wall = MeshInstance3D.new()
		var mesh = BoxMesh.new()
		mesh.size = wall_scales[i]
		wall.mesh = mesh
		wall.position = wall_positions[i]
		wall.material_override = wall_material if wall_material else terrain_material
		add_child(wall)

		var wall_body = StaticBody3D.new()
		var collision = CollisionShape3D.new()
		var shape = BoxShape3D.new()
		shape.size = wall_scales[i]
		collision.shape = shape
		wall_body.position = wall_positions[i]
		wall_body.add_child(collision)
		add_child(wall_body)

func clear_chunks():
	for chunk in chunk_mesh_instances.values():
		if is_instance_valid(chunk):
			chunk.queue_free()
	chunk_mesh_instances.clear()

	for body in chunk_static_bodies.values():
		if is_instance_valid(body):
			body.queue_free()
	chunk_static_bodies.clear()

	chunks.clear()

func get_mouse_world_hit() -> Vector3:
	var viewport := get_viewport()
	var camera := get_viewport().get_camera_3d()
	if not camera:
		return Vector3.ZERO

	var mouse_pos = viewport.get_mouse_position()
	var from = camera.project_ray_origin(mouse_pos)
	var to = from + camera.project_ray_normal(mouse_pos) * 10.0  # Ray length (adjust if needed)

	var space_state := get_world_3d().direct_space_state
	var query = PhysicsRayQueryParameters3D.create(from, to)
	query.collide_with_areas = false
	query.collide_with_bodies = true

	var result = space_state.intersect_ray(query)
	if result:
		return result.position
	return Vector3.ZERO

func update_preview(world_position: Vector3):
	var voxel_pos = to_local(world_position).floor()
	var half = int(brush_radius)

	match current_brush_type:
		BrushType.MODIFY:
			preview_modify(voxel_pos, half)
		BrushType.DIG:
			preview_dig(voxel_pos, half)
		BrushType.FLAT_SQUARE:
			preview_flat_square(voxel_pos, half)
		BrushType.EQUALIZE:
			preview_equalize(voxel_pos, half)

	queue_preview_chunks_for_update(voxel_pos, half)
	
	
func preview_modify(voxel_pos: Vector3, half: int):
	for x in range(voxel_pos.x - half, voxel_pos.x + half + 1):
		if x < 0 or x >= RESOLUTION: continue
		for y in range(voxel_pos.y - half, voxel_pos.y + half + 1):
			if y < 0 or y >= RESOLUTION: continue
			for z in range(voxel_pos.z - half, voxel_pos.z + half + 1):
				if z < 0 or z >= RESOLUTION: continue
				var local_voxel = Vector3(x, y, z)
				if not is_voxel_in_brush_shape(local_voxel, voxel_pos): continue

				var index = grid_index(x, y, z)

				match current_brush_shape:
					BrushShape.CUBE:
						preview_voxel_data[index] = voxel_data[index] - brush_strength
					_:
						var distance = voxel_pos.distance_to(local_voxel)
						var falloff = clamp(1.0 - distance / brush_radius, 0.0, 1.0)
						preview_voxel_data[index] = voxel_data[index] - brush_strength * falloff


func preview_dig(voxel_pos: Vector3, half: int):
	for x in range(voxel_pos.x - half, voxel_pos.x + half + 1):
		if x < 0 or x >= RESOLUTION: continue
		for y in range(voxel_pos.y - half, voxel_pos.y + half + 1):
			if y < 0 or y >= RESOLUTION: continue
			for z in range(voxel_pos.z - half, voxel_pos.z + half + 1):
				if z < 0 or z >= RESOLUTION: continue
				var local_voxel = Vector3(x, y, z)
				if not is_voxel_in_brush_shape(local_voxel, voxel_pos): continue

				var index = grid_index(x, y, z)

				match current_brush_shape:
					BrushShape.CUBE:
						preview_voxel_data[index] = voxel_data[index] + brush_strength
					_:
						var distance = voxel_pos.distance_to(local_voxel)
						var falloff = clamp(1.0 - distance / brush_radius, 0.0, 1.0)
						preview_voxel_data[index] = voxel_data[index] + brush_strength * falloff

func preview_flat_square(voxel_pos: Vector3, half: int):
	var platform_value = 1.0  # Use same logic as apply_flat_square

	var center_x = int(voxel_pos.x)
	var center_y = int(voxel_pos.y)
	var center_z = int(voxel_pos.z)

	for x in range(center_x - half, center_x + half):
		if x < 0 or x >= RESOLUTION: continue
		for z in range(center_z - half, center_z + half):
			if z < 0 or z >= RESOLUTION: continue
			var index = grid_index(x, center_y, z)
			preview_voxel_data[index] = platform_value

func preview_equalize(voxel_pos: Vector3, half: int):
	var sum := 0.0
	var count := 0

	var center_x = int(voxel_pos.x)
	var center_y = int(voxel_pos.y)
	var center_z = int(voxel_pos.z)

	# Calculate average
	for x in range(center_x - half, center_x + half):
		if x < 0 or x >= RESOLUTION: continue
		for z in range(center_z - half, center_z + half):
			if z < 0 or z >= RESOLUTION: continue
			var index = grid_index(x, center_y, z)
			sum += voxel_data[index]
			count += 1

	if count == 0:
		return

	var average = sum / count

	# Apply average to preview
	for x in range(center_x - half, center_x + half):
		if x < 0 or x >= RESOLUTION: continue
		for z in range(center_z - half, center_z + half):
			if z < 0 or z >= RESOLUTION: continue
			var index = grid_index(x, center_y, z)
			preview_voxel_data[index] = average

func queue_preview_chunks_for_update(voxel_pos: Vector3, half: int) -> void:

	preview_chunks_to_update.clear()

	var start_chunk_x = int(max(0, (voxel_pos.x - half) / CHUNK_SIZE))
	var end_chunk_x = int(min(RESOLUTION / CHUNK_SIZE - 1, (voxel_pos.x + half) / CHUNK_SIZE))

	var start_chunk_y = int(max(0, (voxel_pos.y - half) / CHUNK_SIZE))
	var end_chunk_y = int(min(RESOLUTION / CHUNK_SIZE - 1, (voxel_pos.y + half) / CHUNK_SIZE))

	var start_chunk_z = int(max(0, (voxel_pos.z - half) / CHUNK_SIZE))
	var end_chunk_z = int(min(RESOLUTION / CHUNK_SIZE - 1, (voxel_pos.z + half) / CHUNK_SIZE))

	for cx in range(start_chunk_x, end_chunk_x + 1):
		for cy in range(start_chunk_y, end_chunk_y + 1):
			for cz in range(start_chunk_z, end_chunk_z + 1):
				var key = chunk_key(cx, cy, cz)
				preview_chunks_to_update.append(key)

func generate_preview_chunk(cx: int, cy: int, cz: int):
	var vertices = PackedVector3Array()

	var start_x = cx * CHUNK_SIZE
	var start_y = cy * CHUNK_SIZE
	var start_z = cz * CHUNK_SIZE

	var end_x = min(RESOLUTION , start_x + CHUNK_SIZE)
	var end_y = min(RESOLUTION , start_y + CHUNK_SIZE)
	var end_z = min(RESOLUTION , start_z + CHUNK_SIZE)

	for x in range(start_x, end_x + 1):
		for y in range(start_y, end_y + 1):
			for z in range(start_z, end_z + 1):
				march_cube_preview(x, y, z, vertices)

	if vertices.is_empty():
		return

	var st = SurfaceTool.new()
	st.begin(Mesh.PRIMITIVE_TRIANGLES)
	if FLAT_SHADED:
		st.set_smooth_group(-1)
	for v in vertices:
		st.add_vertex(v)
	#st.generate_normals()
	#st.index()
	st.set_material(terrain_material)
	var mesh = st.commit()

	var key = chunk_key(cx, cy, cz)

	var mesh_instance_preview: MeshInstance3D
	if preview_mesh_instances.has(key):
		mesh_instance_preview = preview_mesh_instances[key]
	else:
		mesh_instance_preview = MeshInstance3D.new()
		mesh_instance_preview.name = "PreviewMesh_" + key
		mesh_instance_preview.material_override = preview_material  # use preview mat if you want
		add_child(mesh_instance_preview)
		preview_mesh_instances[key] = mesh_instance_preview

	mesh_instance_preview.mesh = mesh

func march_cube_preview(x: int, y: int, z: int, verts: PackedVector3Array):
	var changed := false
	for dx in [0, 1]:
		for dy in [0, 1]:
			for dz in [0, 1]:
				var nx = x + dx
				var ny = y + dy
				var nz = z + dz
				# Check bounds
				if nx < 0 or nx >= RESOLUTION: continue
				if ny < 0 or ny >= RESOLUTION: continue
				if nz < 0 or nz >= RESOLUTION: continue
				
				var index := grid_index(nx, ny, nz)
				if abs(preview_voxel_data[index] - voxel_data[index]) > 0.001:
					changed = true
					break
			if changed: break
		if changed: break

	if not changed:
		return # Skip cubes that are identical to the original terrain

	# Generate the triangulation using the modified voxel values
	if x < 0 or y < 0 or z < 0 or x >= RESOLUTION - 1 or y >= RESOLUTION - 1 or z >= RESOLUTION - 1:
		return
	var tri = get_triangulation_preview(x, y, z)
	for edge_index in tri:
		if edge_index < 0:
			break
		var edge = EDGES[edge_index]
		var a = POINTS[edge.x]
		var b = POINTS[edge.y]

		var pos_a = Vector3(x + a.x, y + a.y, z + a.z)
		var pos_b = Vector3(x + b.x, y + b.y, z + b.z)

		# Check bounds again for interpolation points
		if pos_a.x < 0 or pos_a.x >= RESOLUTION: continue
		if pos_a.y < 0 or pos_a.y >= RESOLUTION: continue
		if pos_a.z < 0 or pos_a.z >= RESOLUTION: continue
		if pos_b.x < 0 or pos_b.x >= RESOLUTION: continue
		if pos_b.y < 0 or pos_b.y >= RESOLUTION: continue
		if pos_b.z < 0 or pos_b.z >= RESOLUTION: continue

		var val_a = preview_voxel_data[grid_index(pos_a.x, pos_a.y, pos_a.z)]
		var val_b = preview_voxel_data[grid_index(pos_b.x, pos_b.y, pos_b.z)]
		var denom = val_b - val_a
		if abs(denom) < 0.0001:
			verts.append(pos_a)
		else:
			var t = (ISO_LEVEL - val_a) / denom
			verts.append(pos_a + t * (pos_b - pos_a))
			

func get_triangulation_preview(x: int, y: int, z: int) -> Array:
	var idx = 0
	idx |= int(preview_voxel_data[grid_index(x, y, z)] < ISO_LEVEL) << 0
	idx |= int(preview_voxel_data[grid_index(x, y, z + 1)] < ISO_LEVEL) << 1
	idx |= int(preview_voxel_data[grid_index(x + 1, y, z + 1)] < ISO_LEVEL) << 2
	idx |= int(preview_voxel_data[grid_index(x + 1, y, z)] < ISO_LEVEL) << 3
	idx |= int(preview_voxel_data[grid_index(x, y + 1, z)] < ISO_LEVEL) << 4
	idx |= int(preview_voxel_data[grid_index(x, y + 1, z + 1)] < ISO_LEVEL) << 5
	idx |= int(preview_voxel_data[grid_index(x + 1, y + 1, z + 1)] < ISO_LEVEL) << 6
	idx |= int(preview_voxel_data[grid_index(x + 1, y + 1, z)] < ISO_LEVEL) << 7
	return TRIANGULATIONS[idx]

func get_preview_or_original(pos: Vector3) -> float:
	var x = int(pos.x)
	var y = int(pos.y)
	var z = int(pos.z)
	if x < 0 or x >= RESOLUTION or y < 0 or y >= RESOLUTION or z < 0 or z >= RESOLUTION:
		return 0.0  # safe fallback

	var index = grid_index(x, y, z)
	var original = voxel_data[index]
	var preview = preview_voxel_data[index]

	if abs(preview - original) > 0.001:
		return preview
	else:
		return original

func clear_preview():

	for key in preview_mesh_instances.keys():
		var instance = preview_mesh_instances[key]
		if is_instance_valid(instance):
			instance.queue_free()
	preview_mesh_instances = {}

	# Reset preview_voxel_data back to the original voxel_data
	preview_voxel_data = voxel_data.duplicate()

	# Also clear any pending updates
	preview_chunks_to_update.clear()

func update_all_chunks():
	# Clear existing chunks
	for mesh_instance_iterator in chunk_mesh_instances.values():
		mesh_instance_iterator.free()
	chunk_mesh_instances.clear()

	for static_body_iterator in chunk_static_bodies.values():
		static_body_iterator.free()
	chunk_static_bodies.clear()

	# Remove children directly, in case some chunks were manually added
	for child in get_children():
		if child is MeshInstance3D or child is StaticBody3D:
			child.free()

	# Rebuild chunks from current voxel_data
	generate_all_chunks()
	create_all_collision_shapes()
	create_terrain_border()

func cycle_brush_type():
	var brush_names := BrushType.keys()
	var current_index := brush_names.find(BrushType.find_key(current_brush_type))
	current_index = (current_index + 1) % brush_names.size()
	current_brush_type = BrushType[brush_names[current_index]]
	print("Brush type changed to: ", brush_names[current_index])



func mark_dirty_chunks_around_voxel(voxel: Vector3i):
	var cx = voxel.x / CHUNK_SIZE
	var cy = voxel.y / CHUNK_SIZE
	var cz = voxel.z / CHUNK_SIZE

	var local_x = voxel.x % CHUNK_SIZE
	var local_y = voxel.y % CHUNK_SIZE
	var local_z = voxel.z % CHUNK_SIZE

	# Always mark the current chunk
	dirty_chunks[Vector3i(cx, cy, cz)] = true

	# Check each axis for edge cases and mark adjacent chunks
	if local_x == 0 and cx > 0:
		dirty_chunks[Vector3i(cx - 1, cy, cz)] = true
	elif local_x == CHUNK_SIZE - 1 and (cx + 1) * CHUNK_SIZE < RESOLUTION:
		dirty_chunks[Vector3i(cx + 1, cy, cz)] = true

	if local_y == 0 and cy > 0:
		dirty_chunks[Vector3i(cx, cy - 1, cz)] = true
	elif local_y == CHUNK_SIZE - 1 and (cy + 1) * CHUNK_SIZE < RESOLUTION:
		dirty_chunks[Vector3i(cx, cy + 1, cz)] = true

	if local_z == 0 and cz > 0:
		dirty_chunks[Vector3i(cx, cy, cz - 1)] = true
	elif local_z == CHUNK_SIZE - 1 and (cz + 1) * CHUNK_SIZE < RESOLUTION:
		dirty_chunks[Vector3i(cx, cy, cz + 1)] = true


#func _on_brush_done(dirty_chunks: Dictionary) -> void:
	##for chunk_pos in dirty_chunks.keys():
		##generate_chunk(chunk_pos.x, chunk_pos.y, chunk_pos.z)
	#print(" Brush finished. Chunks modified:", dirty_chunks.size())

func _on_chunk_mesh_ready(cx: int, cy: int, cz: int, mesh: ArrayMesh) -> void:
	var key = chunk_key(cx, cy, cz)
	var mesh_instance_new: MeshInstance3D

	if not chunk_mesh_instances.has(key):
		mesh_instance_new = MeshInstance3D.new()
		mesh_instance_new.name = "ChunkMesh_%s" % key
		add_child(mesh_instance_new)
		mesh_instance_new.owner = self.owner
		chunk_mesh_instances[key] = mesh_instance_new
	else:
		mesh_instance_new = chunk_mesh_instances[key]

	mesh_instance_new.mesh = mesh
	create_chunk_collision(cx, cy, cz)

func get_chunk_cache_path(pos: Vector3i) -> String:
	return "user://chunk_cache/%s_%s_%s.res" % [pos.x, pos.y, pos.z]
